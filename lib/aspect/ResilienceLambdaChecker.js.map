{"version":3,"file":"ResilienceLambdaChecker.js","sourceRoot":"","sources":["../../src/aspect/ResilienceLambdaChecker.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA,wEAA0D;AAE1D,0EAAsE;AAStE;;GAEG;AACH,MAAa,uBAAuB;IAIlC,YAAY,KAAoC;QAC9C,IAAI,CAAC,KAAK,GAAG,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,IAAI,CAAA;IAC1B,CAAC;IAEM,KAAK,CAAC,SAAyB;QAEpC,IAAI,SAAS,YAAY,KAAK,CAAC,YAAY,EAAE;YAC3C,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC;YAElF,MAAM,OAAO,GAAG,IAAI,CAAC,qBAAqB,CAAC,SAAS,CAAC,CAAC;YACtD,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;gBACtB,MAAM,eAAe,GAAG,IAAI,CAAC,2BAA2B,CAAC,OAAO,CAAC,CAAC;gBAElE,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE;oBAC9B,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,uCAAuC,eAAe,GAAG,CAAC,CAAC,CAAC;iBAC7F;aACF;iBAAM;gBACL,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,kGAAkG,CAAC,CAAC,CAAC;gBACrI,iDAAiD;aAClD;SACF;IACH,CAAC;IAEO,2BAA2B,CAAC,OAA0B;QAC5D,OAAO,yCAAmB,CAAC,eAAe,CAAC,MAAM,CAAC,cAAc,CAAC,EAAE,CACjE,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,WAAC,OAAA,QAAC,MAAM,CAAC,MAAM,0CAAE,QAAQ,CAAC,cAAc,EAAC,CAAA,EAAA,CAAC,CAAC,CAAC;IACvE,CAAC;IAEO,qBAAqB,CAAC,SAAyB;QACrD,8DAA8D;QAC9D,OAAQ,SAAiB,CAAC,OAA4B,IAAI,EAAE,CAAA;IAC9D,CAAC;CACF;AApCD,0DAoCC","sourcesContent":["import * as cdk from '@aws-cdk/core';\r\nimport * as tasks from '@aws-cdk/aws-stepfunctions-tasks';\r\nimport { RetryProps } from '@aws-cdk/aws-stepfunctions'\r\nimport { ResilientLambdaTask } from '../construct/ResilientLambdaTask'\r\n\r\n/**\r\n * Properties for defining resilience lambda checker aspect.\r\n */\r\nexport interface ResilienceLambdaCheckerProps {\r\n    readonly fail?: boolean;\r\n}\r\n\r\n/**\r\n * Define an aspect that validates all Lambda Invoke tasks and warns if AWS Lambda transient errors are not handled properly.\r\n */\r\nexport class ResilienceLambdaChecker implements cdk.IAspect {\r\n\r\n  private readonly _fail?: boolean;\r\n\r\n  constructor(props?: ResilienceLambdaCheckerProps) {\r\n    this._fail = props?.fail\r\n  }\r\n\r\n  public visit(construct: cdk.IConstruct): void {\r\n\r\n    if (construct instanceof tasks.LambdaInvoke) {\r\n      const reporter = this._fail ? construct.node.addError : construct.node.addWarning;\r\n\r\n      const retries = this.getRetryConfiguration(construct);\r\n      if (retries.length > 0) {\r\n        const unhandledErrors = this.getUnhandledTransientErrors(retries);\r\n\r\n        if (unhandledErrors.length > 0) {\r\n          reporter.apply(construct.node, [`Missing retry for transient errors: ${unhandledErrors}.`]);\r\n        }\r\n      } else {\r\n        reporter.apply(construct.node, ['No retry for AWS Lambda transient errors defined - consider using ResilientLambdaTask construct.']);\r\n        //ResilientLambdaTask.addDefaultRetry(construct);\r\n      }\r\n    }\r\n  }\r\n\r\n  private getUnhandledTransientErrors(retries: Array<RetryProps>): Array<string> {\r\n    return ResilientLambdaTask.TransientErrors.filter(transientError => \r\n      retries.every(config => !config.errors?.includes(transientError)));\r\n  }\r\n\r\n  private getRetryConfiguration(construct: cdk.IConstruct): Array<RetryProps> {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    return (construct as any).retries as Array<RetryProps> || []\r\n  }\r\n}\r\n"]}
{"version":3,"file":"LoopTask.js","sourceRoot":"","sources":["../../src/construct/LoopTask.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,mDAAqC;AAErC,gEAAkD;AAClD,yCAAsC;AA6CtC;;GAEG;AACH,MAAa,QAAS,SAAQ,GAAG,CAAC,oBAAoB;IAMpD,YAAY,KAAoB,EAAE,EAAU,EAAE,KAAqB;QACjE,KAAK,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;QACjB,MAAM,EACJ,eAAe,EACf,aAAa,EACb,WAAW,GAAG,EAAE,EAChB,eAAe,EACf,cAAc,EACd,UAAU,GAAG,UAAU,EACvB,iBAAiB,GAAG,QAAQ,GAC7B,GAAG,KAAK,CAAC;QAEV,MAAM,UAAU,GAAG,GAAG,UAAU,IAAI,iBAAiB,EAAE,CAAC;QAExD,IAAI,CAAC,MAAM,GAAG,IAAI,mBAAQ,CAAC,IAAI,EAAE,MAAM,EAAE;YACvC,UAAU,EAAE,SAAS;YACrB,eAAe;YACf,aAAa,kBACX,IAAI,EAAE,eAAe,IAClB,aAAa,CACjB;SACF,CAAC,CAAC;QAEH,IAAI,CAAC,MAAM,GAAG,IAAI,mBAAQ,CAAC,IAAI,EAAE,QAAQ,EAAE;YACzC,UAAU,EAAE,UAAU;YACtB,eAAe;YACf,aAAa,kBACX,IAAI,EAAE,cAAc,IACjB,aAAa,CACjB;SACF,CAAC,CAAC;QAEH,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE;YACtC,IAAI,EAAE,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;SAC/D,CAAC,CAAC;QAEH,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;QAE3C,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;QAE3C,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC;aACzB,IAAI,CAAC,IAAI,CAAC;aACV,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;aACjB,IAAI,CACH,IAAI,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC;aAC3B,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,YAAY,CAAC,UAAU,EAAE,SAAS,CAAC,EAAE,IAAI,CAAC;aAC7D,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,YAAY,CAAC,UAAU,EAAE,SAAS,CAAC,EAAE,IAAI,CAAC;aAC7D,SAAS,CAAC,IAAI,CAAC;aACf,UAAU,EAAE,CAChB,CAAC;QAEJ,4EAA4E;QAC5E,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC;QACzC,IAAI,CAAC,SAAS,GAAG,CAAC,IAAI,CAAC,CAAC;IAC1B,CAAC;IAED,QAAQ,CAAC,OAAuB,EAAE,KAAsB;QACtD,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACrC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACrC,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AAnED,4BAmEC","sourcesContent":["import * as cdk from '@aws-cdk/core';\r\nimport * as lambda from '@aws-cdk/aws-lambda';\r\nimport * as sfn from '@aws-cdk/aws-stepfunctions';\r\nimport { CodeTask } from './CodeTask';\r\n\r\n\r\nexport namespace LoopTask {\r\n  export type FunctionProps = Partial<Omit<CodeTask.FunctionProps, 'code'>>;\r\n\r\n  export interface Props {\r\n    /**\r\n     * The payload that is used for the `InvokeFunction` task.\r\n     */\r\n    functionPayload?: { [key: string]: unknown };\r\n    /**\r\n     * The props that are passed to the Lambda function.\r\n     */\r\n    functionProps?: FunctionProps;\r\n    /**\r\n     * The amount of seconds the wait step will wait before looping.\r\n     *\r\n     * @default 10\r\n     */\r\n    waitSeconds?: number;\r\n    /**\r\n     * The main execution code.\r\n     */\r\n    executeStepCode: lambda.Code;\r\n    /**\r\n     * The code that will be executed to verify the outcome of the execution step. The code must return an object\r\n     * containing the given `verifyStatusField` field.\r\n     */\r\n    verifyStepCode: lambda.Code;\r\n    /**\r\n     * The path where the verify steps result will be stored.\r\n     *\r\n     * @default $.verify\r\n     */\r\n    verifyPath?: string;\r\n    /**\r\n     * The field that contains the status of the verify step.\r\n     *\r\n     * @default status\r\n     */\r\n    verifyStatusField?: string;\r\n  }\r\n}\r\n\r\n/**\r\n * Class that represents a step function execute, wait and verify loop.\r\n */\r\nexport class LoopTask extends sfn.StateMachineFragment {\r\n  public readonly startState: sfn.State;\r\n  public readonly endStates: sfn.INextable[];\r\n  private readonly deploy: CodeTask;\r\n  private readonly verify: CodeTask;\r\n\r\n  constructor(scope: cdk.Construct, id: string, props: LoopTask.Props) {\r\n    super(scope, id);\r\n    const {\r\n      functionPayload,\r\n      functionProps,\r\n      waitSeconds = 10,\r\n      executeStepCode,\r\n      verifyStepCode,\r\n      verifyPath = '$.verify',\r\n      verifyStatusField = 'status',\r\n    } = props;\r\n\r\n    const statusPath = `${verifyPath}.${verifyStatusField}`;\r\n\r\n    this.deploy = new CodeTask(this, `Exec`, {\r\n      resultPath: 'DISCARD',\r\n      functionPayload,\r\n      functionProps: {\r\n        code: executeStepCode,\r\n        ...functionProps,\r\n      },\r\n    });\r\n\r\n    this.verify = new CodeTask(this, `Verify`, {\r\n      resultPath: verifyPath,\r\n      functionPayload,\r\n      functionProps: {\r\n        code: verifyStepCode,\r\n        ...functionProps,\r\n      },\r\n    });\r\n\r\n    const wait = new sfn.Wait(this, `Wait`, {\r\n      time: sfn.WaitTime.duration(cdk.Duration.seconds(waitSeconds)),\r\n    });\r\n\r\n    const pass = new sfn.Pass(this, `Success`);\r\n\r\n    const fail = new sfn.Fail(this, `Failure`);\r\n\r\n    sfn.Chain.start(this.deploy)\r\n      .next(wait)\r\n      .next(this.verify)\r\n      .next(\r\n        new sfn.Choice(this, `Choice`)\r\n          .when(sfn.Condition.stringEquals(statusPath, 'SUCCESS'), pass)\r\n          .when(sfn.Condition.stringEquals(statusPath, 'FAILURE'), fail)\r\n          .otherwise(wait)\r\n          .afterwards(),\r\n      );\r\n\r\n    // Not sure why but we cannot use chain.startState and chain.endStates here.\r\n    this.startState = this.deploy.startState;\r\n    this.endStates = [pass];\r\n  }\r\n\r\n  addCatch(handler: sfn.IChainable, props?: sfn.CatchProps): this {\r\n    this.deploy.addCatch(handler, props);\r\n    this.verify.addCatch(handler, props);\r\n    return this;\r\n  }\r\n}\r\n"]}
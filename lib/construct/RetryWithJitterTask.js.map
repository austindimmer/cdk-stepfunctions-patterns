{"version":3,"file":"RetryWithJitterTask.js","sourceRoot":"","sources":["../../src/construct/RetryWithJitterTask.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,mDAAqC;AACrC,4DAA8C;AAC9C,gEAAkD;AAClD,+DAA2D;AAC3D,mCAAgC;AA8ChC;;GAEG;AACH,MAAa,mBAAoB,SAAQ,GAAG,CAAC,QAAQ;IAEnD,YAAY,KAAoB,EAAE,EAAU,EAAE,KAA2B;QACvE,MAAM,aAAa,GAAG;YACpB,OAAO,EAAE,KAAK,CAAC,OAAO;YACtB,SAAS,EAAE,KAAK,CAAC,SAAS;YAC1B,UAAU,EAAE,MAAM;YAClB,UAAU,EAAE,KAAK,CAAC,UAAU;YAC5B,UAAU,EAAE;gBACV,cAAc,EAAE,qBAAqB;gBACrC,SAAS,EAAE,GAAG;aACf;SACF,CAAA;QAED,KAAK,CAAC,KAAK,EAAE,EAAE,EAAE,aAAa,CAAC,CAAA;QAE/B,MAAM,qBAAqB,GAAG,IAAI,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,uBAAuB,EAAE;YAC/E,OAAO,EAAE,MAAM,CAAC,OAAO,CAAC,UAAU;YAClC,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,GAAG,sBAAsB,CAAC;YAC/D,OAAO,EAAE,qBAAqB;SAC/B,CAAC,CAAC;QAEH,MAAM,mBAAmB,GAAG,IAAI,yCAAmB,CAAC,IAAI,EAAE,aAAK,CAAC,eAAe,CAAC,KAAK,CAAC,eAAgB,EAAE,iBAAiB,CAAC,EAAE;YAE1H,cAAc,EAAE,qBAAqB;YACrC,OAAO,EAAE,GAAG,CAAC,SAAS,CAAC,UAAU,CAAC;gBAChC,cAAc,EAAE,cAAc;gBAC9B,SAAS,EAAE,CAAC;aACb,CAAC;YACF,UAAU,EAAE,eAAe;SAC5B,CAAC,CAAA;QAEF,MAAM,QAAQ,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,aAAK,CAAC,eAAe,CAAC,KAAK,CAAC,eAAgB,EAAE,oBAAoB,CAAC,EAAE;YACvG,IAAI,EAAE,GAAG,CAAC,QAAQ,CAAC,WAAW,CAAC,eAAe,CAAC;SAChD,CAAC,CAAA;QAEF,2DAA2D;QAC3D,yFAAyF;QACzF,MAAM,eAAe,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,aAAK,CAAC,eAAe,CAAC,KAAK,CAAC,eAAgB,EAAE,cAAc,CAAC,EAAE;YACxG,UAAU,EAAE,SAAS;SACtB,CAAC,CAAA;QAEF,MAAM,SAAS,GAAG,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,CAAA;QAE1E,MAAM,WAAW,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,aAAK,CAAC,eAAe,CAAC,KAAK,CAAC,eAAgB,EAAE,iBAAiB,CAAC,CAAC;aACvG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,iBAAiB,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,SAAS,CAAC;aACnE,SAAS,CAAC,eAAe,CAAC;aAC1B,UAAU,EAAE;aACZ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAA;QAEzB,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAA;QAExB,IAAI,CAAC,QAAQ,CAAC;YACZ,QAAQ,EAAE,GAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;YACjC,WAAW,EAAE,KAAK,CAAC,UAAU,CAAC,WAAW;YACzC,MAAM,EAAE,KAAK,CAAC,UAAU,CAAC,MAAM;SAChC,CAAC,CAAA;IACJ,CAAC;CACF;AA1DD,kDA0DC","sourcesContent":["import * as cdk from '@aws-cdk/core';\nimport * as lambda from '@aws-cdk/aws-lambda';\nimport * as sfn from '@aws-cdk/aws-stepfunctions';\nimport { ResilientLambdaTask } from './ResilientLambdaTask'\nimport { Utils } from './utils';\n\n/**\n * Properties for defining a retry with backoff and jitter construct.\n */\nexport interface RetryWithJitterProps {\n  /**\n   * An optional description for this state\n   *\n   * @default No comment\n   */\n  readonly comment?: string;\n  /**\n   * JSONPath expression to select part of the state to be the input to this state.\n   *\n   * May also be the special value DISCARD, which will cause the effective\n   * input to be the empty object {}.\n   *\n   * @default $\n   */\n  readonly inputPath?: string;\n  /**\n   * JSONPath expression to indicate where to inject the state's output\n   *\n   * May also be the special value DISCARD, which will cause the state's\n   * input to become its output.\n   *\n   * @default $\n   */\n  readonly resultPath?: string;\n\n  /**\n   * Try chain to execute.\n   */\n  readonly tryProcess: sfn.IChainable;\n\n  /**\n   * Retry configuration.\n   */\n  readonly retryProps: sfn.RetryProps;\n  /**\n  * Optional State Name Prefix for the States, can be used if you observe the \"Invalid State Machine Definition: 'INVALID_STATE_NAME: Invalid State name: State exceeds the 80-character limit allowed by the service error when deploying.\n  */\n  readonly stateNamePrefix?: string\n}\n\n/**\n * Define a construct that implements retry with backoff and jitter.\n */\nexport class RetryWithJitterTask extends sfn.Parallel {\n\n  constructor(scope: cdk.Construct, id: string, props: RetryWithJitterProps) {\n    const parallelProps = {\n      comment: props.comment,\n      inputPath: props.inputPath,\n      outputPath: \"$[0]\",\n      resultPath: props.resultPath,\n      parameters: {\n        \"RetryCount.$\": \"$$.State.RetryCount\",\n        \"Input.$\": \"$\"\n      }\n    }\n\n    super(scope, id, parallelProps)\n\n    const calculateJitterLambda = new lambda.Function(this, 'CalculateJitterLambda', {\n      runtime: lambda.Runtime.PYTHON_3_8,\n      code: lambda.Code.fromAsset(__dirname + '/../../lambda/jitter'),\n      handler: \"main.lambda_handler\",\n    });\n\n    const calculateJitterTask = new ResilientLambdaTask(this, Utils.createStateName(props.stateNamePrefix!, \"CalculateJitter\"), {\n\n      lambdaFunction: calculateJitterLambda,\n      payload: sfn.TaskInput.fromObject({\n        \"RetryCount.$\": \"$.RetryCount\",\n        \"Backoff\": 2\n      }),\n      resultPath: \"$.WaitSeconds\",\n    })\n\n    const waitTask = new sfn.Wait(this, Utils.createStateName(props.stateNamePrefix!, \"WaitBetweenRetries\"), {\n      time: sfn.WaitTime.secondsPath(\"$.WaitSeconds\"),\n    })\n\n    // Need this state to \"unwrap\" original input to the state.\n    // Also, CDK does not support outputPath for Wait state, which I would use for retry path\n    const unwrapArguments = new sfn.Pass(this, Utils.createStateName(props.stateNamePrefix!, 'Unwrap Input'), {\n      outputPath: \"$.Input\"\n    })\n\n    const retryPath = calculateJitterTask.next(waitTask).next(unwrapArguments)\n\n    const choiceState = new sfn.Choice(this, Utils.createStateName(props.stateNamePrefix!, \"CheckRetryCount\"))\n      .when(sfn.Condition.numberGreaterThan(\"$.RetryCount\", 0), retryPath)\n      .otherwise(unwrapArguments)\n      .afterwards()\n      .next(props.tryProcess)\n\n    this.branch(choiceState)\n\n    this.addRetry({\n      interval: cdk.Duration.seconds(0),\n      maxAttempts: props.retryProps.maxAttempts,\n      errors: props.retryProps.errors\n    })\n  }\n}"]}
{"version":3,"file":"TryTask.js","sourceRoot":"","sources":["../../src/construct/TryTask.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA,gEAAkD;AAClD,mCAAgC;AA6DhC;;GAEG;AACH,MAAa,OAAQ,SAAQ,GAAG,CAAC,QAAQ;IAEvC,YAAY,KAAoB,EAAE,EAAU,EAAE,KAAe;QAC3D,MAAM,aAAa,GAAG;YACpB,OAAO,EAAE,KAAK,CAAC,OAAO;YACtB,SAAS,EAAE,KAAK,CAAC,SAAS;YAC1B,UAAU,EAAE,MAAM;YAClB,UAAU,EAAE,KAAK,CAAC,UAAU;SACR,CAAA;QAEtB,KAAK,CAAC,KAAK,EAAE,EAAE,EAAE,aAAa,CAAC,CAAA;QAE/B,IAAI,OAAO,GAAG,KAAK,CAAC,UAAU,CAAC;QAE/B,IAAI,KAAK,CAAC,YAAY,EAAE;YACtB,OAAO,GAAG,IAAI,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE,aAAK,CAAC,eAAe,CAAC,KAAK,CAAC,eAAgB,EAAE,UAAU,CAAC,EAAE;gBAC1F,UAAU,EAAE,MAAM,CAAC,iDAAiD;aACrE,CAAC;iBACC,MAAM,CAAC,OAAO,CAAC;iBACf,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;SACnD;QAED,IAAI,KAAK,CAAC,cAAc,EAAE;YACxB,OAAO,GAAG,IAAI,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE,aAAK,CAAC,eAAe,CAAC,KAAK,CAAC,eAAgB,EAAE,YAAY,CAAC,EAAE;gBAC5F,UAAU,EAAE,MAAM,CAAC,iDAAiD;aACrE,CAAC;iBACC,MAAM,CAAC,OAAO,CAAC;iBACf,QAAQ,CAAC,KAAK,CAAC,cAAc,EAAE;gBAC9B,UAAU,EAAE,KAAK,CAAC,gBAAgB;aACnC,CAAC;iBACD,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;SAC/B;QAED,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IACvB,CAAC;CACF;AAnCD,0BAmCC","sourcesContent":["import * as cdk from '@aws-cdk/core';\r\nimport * as sfn from '@aws-cdk/aws-stepfunctions';\r\nimport { Utils } from './utils';\r\n\r\n/**\r\n * Properties for defining a try/catch/finally construct.\r\n */\r\nexport interface TryProps {\r\n  /**\r\n   * An optional description for this state\r\n   *\r\n   * @default No comment\r\n   */\r\n  readonly comment?: string;\r\n  /**\r\n   * JSONPath expression to select part of the state to be the input to this state.\r\n   *\r\n   * May also be the special value DISCARD, which will cause the effective\r\n   * input to be the empty object {}.\r\n   *\r\n   * @default $\r\n   */\r\n  readonly inputPath?: string;\r\n  /**\r\n   * JSONPath expression to indicate where to inject the state's output\r\n   *\r\n   * May also be the special value DISCARD, which will cause the state's\r\n   * input to become its output.\r\n   *\r\n   * @default $\r\n   */\r\n  readonly resultPath?: string;\r\n\r\n  /**\r\n   * Try chain to execute.\r\n   */\r\n  readonly tryProcess: sfn.IChainable;\r\n\r\n  /**\r\n   * Catch properties.\r\n   */\r\n  readonly catchProps?: sfn.CatchProps; // provide catch-all default\r\n\r\n  /**\r\n   * Optional catch chain to execute.\r\n   */\r\n  readonly catchProcess?: sfn.IChainable;\r\n\r\n  /**\r\n   * JSONPath expression to indicate where to map caught exception details.\r\n   */\r\n  readonly finallyErrorPath?: string;\r\n\r\n  /**\r\n   * Optional finally chain to execute.\r\n   */\r\n  readonly finallyProcess?: sfn.IChainable;\r\n  /**\r\n   * Optional State Name Prefix for the States, can be used if you observe the \"Invalid State Machine Definition: 'INVALID_STATE_NAME: Invalid State name: State exceeds the 80-character limit allowed by the service error when deploying.\r\n   */\r\n  readonly stateNamePrefix?: string\r\n}\r\n\r\n/**\r\n * Define a construct that helps with handling StepFunctions exceptions.\r\n */\r\nexport class TryTask extends sfn.Parallel {\r\n\r\n  constructor(scope: cdk.Construct, id: string, props: TryProps) {\r\n    const parallelProps = {\r\n      comment: props.comment,\r\n      inputPath: props.inputPath,\r\n      outputPath: \"$[0]\",\r\n      resultPath: props.resultPath\r\n    } as sfn.ParallelProps\r\n\r\n    super(scope, id, parallelProps)\r\n\r\n    let process = props.tryProcess;\r\n\r\n    if (props.catchProcess) {\r\n      process = new sfn.Parallel(this, Utils.createStateName(props.stateNamePrefix!, 'TryCatch'), {\r\n        outputPath: \"$[0]\" // unwrap result from the first (and only) branch\r\n      })\r\n        .branch(process)\r\n        .addCatch(props.catchProcess, props.catchProps);\r\n    }\r\n\r\n    if (props.finallyProcess) {\r\n      process = new sfn.Parallel(this, Utils.createStateName(props.stateNamePrefix!, 'TryFinally'), {\r\n        outputPath: \"$[0]\" // unwrap result from the first (and only) branch\r\n      })\r\n        .branch(process)\r\n        .addCatch(props.finallyProcess, {\r\n          resultPath: props.finallyErrorPath\r\n        })\r\n        .next(props.finallyProcess);\r\n    }\r\n\r\n    this.branch(process);\r\n  }\r\n}"]}